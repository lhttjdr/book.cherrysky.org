<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言学习笔记 on 编程语言笔记</title><link>https://book.cherrysky.org/programming/</link><description>Recent content in 编程语言学习笔记 on 编程语言笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://book.cherrysky.org/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1.1 图灵机</title><link>https://book.cherrysky.org/programming/introduction/turing-machine/turing_machine/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/introduction/turing-machine/turing_machine/</guid><description>形式定义 一台图灵机是一个七元有序组$M=&amp;lt;Q, \Gamma, b, \Sigma, \delta, q_0, F&amp;gt;$，其中：
$Q$是非空有穷状态(state)集合； $\Gamma$ 是非空有穷带字母表(Tape alphabet)； $b \in \Gamma$ 为空白符(blank symbol)，也是唯一允许出现无限次的字符； $\Sigma\subseteq \Gamma\setminus \{b\}$ 是非空有穷输入字母表(input symbol)，初始时出现在带Tape上的内容； $q_0 \in Q$ 是起始状态； $F \subseteq Q$是终止状态(final state)或接受状态(accepted state)。初始时带上的内容是被$M$接受的，当且仅当图灵机$M$最终停在接受状态。 $\delta :(Q\setminus F) \times \Gamma \to Q\times \Gamma \times \{L,R\}$ 是转移函数(transition function)，其中$L$, $R$表示读写头是向左移还是向右移；它是一个部分函数(partial function)，换句话说对于某些状态$q$和字符$x$，$\delta(q,x)$可能没有定义，如果在运行中遇到没有定义的情况，机器将立刻停机。 除此外，还可显式地定义拒绝状态（rejected state），它是一种特殊的停机状态。原本$\delta(q,x)$未定义会造成停机，那么也可以给它一个定义，使之转移到拒绝状态而停机。在这种情况下，图灵机有三种状态：接受，拒绝，永不停机。
还有一个不常见的变种，允许转移函数中除了左右移动，还可以保持原地不动，即在上面的定义中用$\{L,R,N\}$代替$\{L,R\}$，其中$N$表示不移动(no shift, stay)。
基本术语 实例 P'' 语言 Brainfuck语言 下面是一个演示程序：
冯诺依曼模型</description></item><item><title>1.2.1 无类型$\lambda$演算</title><link>https://book.cherrysky.org/programming/introduction/lambda/untyped/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/introduction/lambda/untyped/</guid><description>无类型$\lambda$演算 $\lambda$表达式 无歧义地定义一系列元素，构成可数集合，记$\mathit{VAR}$。对任意的$x \in \mathit{VAR}$，$\lambda$表达式$M$可以递归地定义如下：
(变量, variable) 变量$x$为一个$\lambda$表达式。 (函数应用, application) 若$M$和$N$为$\lambda$表达式，则$(M\ N)$为$\lambda$表达式。 (函数抽象, abstraction) 若$x$为变量，$M$为lambda表达式，则$(\lambda x.M)$为$\lambda$表达式。 从$\mathit{VAR}$产生的所有的$\lambda$表达式构成的集合是一种形式语言，记为$\Lambda$。
使用BNF范式，可写成 $$ \def\wideOr{\mathrel{\,\,|\,}} \begin{array}{lcll} M &amp;amp; ::= &amp;amp; x &amp;amp; \text{(变量, variable)} \\
&amp;amp; \wideOr &amp;amp; (\lambda x.M) &amp;amp; \text{(抽象, abstraction)} \\
&amp;amp; \wideOr &amp;amp; (M\ M) &amp;amp; \text{(应用, application)} \end{array} $$
$\lambda$表达式的各部分名称如下:
$$ \displaystyle{ (\overbrace{(\lambda \underbrace{w}_\text{形式参数, parameter}.\underbrace{(w\ w)}_\text{函数体,function body})}^\text{函数, function} \overbrace{(\lambda o.(o\ o))}^\text{实际参数, argument})} $$
通过如下语法约定，可以减少括号的使用 $$ \begin{eqnarray} \lambda x_1 x_2 x_3\cdots x_n .</description></item><item><title>2.1 $\varsigma$演算</title><link>https://book.cherrysky.org/programming/object-oriented-programming/sigma/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/object-oriented-programming/sigma/</guid><description/></item><item><title>4.1 图说 响应式编程常用函数</title><link>https://book.cherrysky.org/programming/reactive-programming/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/examples/</guid><description/></item><item><title>1.2.2 带类型$\lambda$演算</title><link>https://book.cherrysky.org/programming/introduction/lambda/typed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/introduction/lambda/typed/</guid><description/></item><item><title>4.2 TypeScript语言</title><link>https://book.cherrysky.org/programming/reactive-programming/javascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/javascript/</guid><description>Promise Generator函数 RxJS 以rxjs为例，它解决的是下表中Observable的部分。
单值 多值 拉取 Function Iterator 推送 Promise Observable</description></item><item><title>1.2.3 $\lambda$演算计算器</title><link>https://book.cherrysky.org/programming/introduction/lambda/calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/introduction/lambda/calculator/</guid><description> 以下出自马萨里克大学（Masaryk University）的JAKUB KADLECAJ的本科学位论文，开源代码 https://gitlab.com/kdlcj/lambda，遵循CC0 1.0协议。为适合嵌入网页中动作行为，已经修改了某些跳转链接的target。</description></item><item><title>4.3 Java语言</title><link>https://book.cherrysky.org/programming/reactive-programming/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/java/</guid><description>单值 多值 拉取(同步) Function (迭代器/生成器) 推送(异步) CompletableFuture (流) 4.2.1 Function 函数 这个是最常见的语法，即当调用者调用一个函数时，同步地返回一个值。
4.2.2 CompletableFuture Future Future是Java1.5引入的功能。它配合Callable或Runnable可以方便地实现异步调用。
sequenceDiagram Main-ExecutorService: 提交Callable activate ExecutorService ExecutorService-+Thread-1: 创建线程，执行Callable ExecutorService--Main: 返回Future deactivate ExecutorService Main-Main: 其他任意工作 Main-Thread-1: Future.get() Thread-1---Main: 返回结果 要注意，Future.get()是阻塞的。如果调用者在实际任务未完成前就调用get，那就需要一直等待（当然，超时时间是可以设置的）。 import java.util.concurrent.*; public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException { // 线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable&amp;lt;String&amp;gt; callable = new Callable&amp;lt;String&amp;gt;() { @Override public String call() { // Perform some computation System.</description></item></channel></rss>