<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>第四章 响应式编程 on 编程语言笔记</title><link>https://book.cherrysky.org/programming/reactive-programming/</link><description>Recent content in 第四章 响应式编程 on 编程语言笔记</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="https://book.cherrysky.org/programming/reactive-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>4.1 图说 响应式编程常用函数</title><link>https://book.cherrysky.org/programming/reactive-programming/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/examples/</guid><description/></item><item><title>4.2 TypeScript语言</title><link>https://book.cherrysky.org/programming/reactive-programming/javascript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/javascript/</guid><description>Promise Generator函数 RxJS 以rxjs为例，它解决的是下表中Observable的部分。
单值 多值 拉取 Function Iterator 推送 Promise Observable</description></item><item><title>4.3 Java语言</title><link>https://book.cherrysky.org/programming/reactive-programming/java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://book.cherrysky.org/programming/reactive-programming/java/</guid><description>单值 多值 拉取(同步) Function (迭代器/生成器) 推送(异步) CompletableFuture (流) 4.2.1 Function 函数 这个是最常见的语法，即当调用者调用一个函数时，同步地返回一个值。
4.2.2 CompletableFuture Future Future是Java1.5引入的功能。它配合Callable或Runnable可以方便地实现异步调用。
sequenceDiagram Main-ExecutorService: 提交Callable activate ExecutorService ExecutorService-+Thread-1: 创建线程，执行Callable ExecutorService--Main: 返回Future deactivate ExecutorService Main-Main: 其他任意工作 Main-Thread-1: Future.get() Thread-1---Main: 返回结果 要注意，Future.get()是阻塞的。如果调用者在实际任务未完成前就调用get，那就需要一直等待（当然，超时时间是可以设置的）。 import java.util.concurrent.*; public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException { // 线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable&amp;lt;String&amp;gt; callable = new Callable&amp;lt;String&amp;gt;() { @Override public String call() { // Perform some computation System.</description></item></channel></rss>