[{"uri":"https://book.cherrysky.org/programming/introduction/turing-machine/","title":"1.1 图灵机","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/introduction/turing-machine/turing_machine/","title":"1.1.1 图灵机","tags":null,"description":"","content":"形式定义 一台图灵机是一个七元有序组$M=\u0026lt;Q, \\Gamma, b, \\Sigma, \\delta, q_0, F\u0026gt;$，其中：\n $Q$是非空有穷状态(state)集合； $\\Gamma$ 是非空有穷带字母表(Tape alphabet)； $b \\in \\Gamma$ 为空白符(blank symbol)，也是唯一允许出现无限次的字符； $\\Sigma\\subseteq \\Gamma\\setminus \\{b\\}$ 是非空有穷输入字母表(input symbol)，初始时出现在带Tape上的内容； $q_0 \\in Q$ 是起始状态； $F \\subseteq Q$是终止状态(final state)或接受状态(accepted state)。初始时带上的内容是被$M$接受的，当且仅当图灵机$M$最终停在接受状态。 $\\delta :(Q\\setminus F) \\times \\Gamma \\to Q\\times \\Gamma \\times \\{L,R\\}$ 是转移函数(transition function)，其中$L$, $R$表示读写头是向左移还是向右移；它是一个部分函数(partial function)，换句话说对于某些状态$q$和字符$x$，$\\delta(q,x)$可能没有定义，如果在运行中遇到没有定义的情况，机器将立刻停机。  除此外，还可显式地定义拒绝状态（rejected state），它是一种特殊的停机状态。原本$\\delta(q,x)$未定义会造成停机，那么也可以给它一个定义，使之转移到拒绝状态而停机。在这种情况下，图灵机有三种状态：接受，拒绝，永不停机。\n还有一个不常见的变种，允许转移函数中除了左右移动，还可以保持原地不动，即在上面的定义中用$\\{L,R,N\\}$代替$\\{L,R\\}$，其中$N$表示不移动(no shift, stay)。\n基本术语 实例 P'' 语言 Brainfuck语言 下面是一个演示程序：\n  冯诺依曼模型 "},{"uri":"https://book.cherrysky.org/programming/introduction/lambda/untyped/","title":"1.2.1 无类型$\\lambda$演算","tags":null,"description":"","content":"无类型$\\lambda$演算 $\\lambda$表达式 无歧义地定义一系列元素，构成可数集合，记$\\mathit{VAR}$。对任意的$x \\in \\mathit{VAR}$，$\\lambda$表达式$M$可以递归地定义如下：\n (变量, variable) 变量$x$为一个$\\lambda$表达式。 (函数应用, application) 若$M$和$N$为$\\lambda$表达式，则$(M\\ N)$为$\\lambda$表达式。 (函数抽象, abstraction) 若$x$为变量，$M$为lambda表达式，则$(\\lambda x.M)$为$\\lambda$表达式。  从$\\mathit{VAR}$产生的所有的$\\lambda$表达式构成的集合是一种形式语言，记为$\\Lambda$。\n使用BNF范式，可写成 $$ \\def\\wideOr{\\mathrel{\\,\\,|\\,}} \\begin{array}{lcll} M \u0026amp; ::= \u0026amp; x \u0026amp; \\text{(变量, variable)} \\\\\n\u0026amp; \\wideOr \u0026amp; (\\lambda x.M) \u0026amp; \\text{(抽象, abstraction)} \\\\\n\u0026amp; \\wideOr \u0026amp; (M\\ M) \u0026amp; \\text{(应用, application)} \\end{array} $$\n$\\lambda$表达式的各部分名称如下:\n$$ \\displaystyle{ (\\overbrace{(\\lambda \\underbrace{w}_\\text{形式参数, parameter}.\\underbrace{(w\\ w)}_\\text{函数体,function body})}^\\text{函数, function} \\overbrace{(\\lambda o.(o\\ o))}^\\text{实际参数, argument})} $$\n通过如下语法约定，可以减少括号的使用 $$ \\begin{eqnarray} \\lambda x_1 x_2 x_3\\cdots x_n . M \u0026amp; \\equiv \u0026amp; (\\lambda x_1.(\\lambda x_2.(\\lambda x_3.(\\cdots (\\lambda x_n.M)\\cdots)))) \\nonumber \\\\\nM_1\\ M_2\\ M_3 \\cdots\\ M_n \u0026amp; \\equiv \u0026amp; (\\cdots ((M_1\\ M_2)\\ M_3) \\cdots\\ M_n) \\nonumber \\\\\n\\lambda x.M_1\\ M_2\\ M_3 \\cdots\\ M_n \u0026amp;\\equiv \u0026amp; (\\lambda x.(M_1\\ M_2\\ M_3 \\cdots\\ M_n)) \\nonumber \\end{eqnarray} $$ 前两条描述的是结合性：函数抽象是右结合的（right-associative），函数应用是左结合的（left-associative）。最后一条描述的是优先级：函数应用的优先级高于函数抽象。\n概念 自由变量与约束变量 一个$\\lambda$表达式的自由变量(free variable)由映射$FV : \\Lambda \\to { \\mathit{VAR} }$来定义。 $$ \\begin{array}{rcl} FV(x) \u0026amp; = \u0026amp; \\{x\\} \\\\\nFV(M\\ N) \u0026amp;=\u0026amp; FV(M) \\cup FV(N) \\\\\nFV(\\lambda x.M) \u0026amp;=\u0026amp; FV(M) \\setminus \\{x\\} \\\\\n\\end{array} $$ 若变量出现在$\\lambda$表达式中，且不是自由变量，则称为约束变量(bounded variable)。形式化定义如下, $$ \\begin{array}{rcl} BV(y) \u0026amp; = \u0026amp; \\{\\} \\\\\nBV(M\\ N) \u0026amp;=\u0026amp; BV(M) \\cup BV(N) \\\\\nBV(\\lambda y.M) \u0026amp;=\u0026amp; BV(M) \\cup \\{y\\} \\\\\n\\end{array} $$\n新鲜变量 既不是自由变量也不是约束变量的称为新鲜变量(fresh variable). 对于$\\lambda$表达式$M$, $Fresh(M)$表示了全集$\\mathit{VAR}$中$FV(M)\\cup BV(M)$的补集。 $$\\mathit{Fresh}(M) = \\{x\\in \\mathit{VAR} | x\\notin FV(M) \\cup BV(M) \\}$$\n组合子 若$\\lambda$表达式$M$满足$FV(M)=\\{\\}$，则称$M$为组合子（combinator）。\n变量替换 变量替换（substitution）是$\\lambda$的基本操作。\n以$N$替换$M$中的变量$x$,其结果记为$M[x:=N]$,也写作$[x/N]M$. $$ \\begin{array}{rcl} y[x:=N] \u0026amp; \\equiv \u0026amp; \\begin{cases} N\\hphantom{NNNNNNNN}\\hphantom{\\lambda y.M} \u0026amp; \\text{当} x=y \\\\\ny \u0026amp; \\text{其它} \\end{cases} \\\\\n(M_1\\ M_2)[x:=N] \u0026amp; \\equiv \u0026amp; (M_1[x:=N])(M_2[x:=N]) \\\\\n(\\lambda y.M)[x:=N] \u0026amp; \\equiv \u0026amp; \\begin{cases} \\lambda y.M \\hphantom{NNNNNNNN}\\hphantom{N} \u0026amp; \\text{当} x=y \\\\\n\\lambda y.M[x:=N] \u0026amp; \\text{当} x\\neq y \\land (x\\notin FV(M) \\lor y\\notin FV(N)) \\\\\n\\lambda z.M[y:=z][x:=N] \u0026amp; \\text{其它; 其中}z\\text{为第一个满足条件}z \\notin \\{x\\} \\cup FV(M) \\cup FV(N)\\text{的变量} \\\\\n\\end{cases} \\end{array} $$\n也可以展开来写\n$$ \\begin{array}{rcll} x[x:=N] \u0026amp; \\equiv \u0026amp; N \u0026amp; \\\\\ny[x:=N] \u0026amp; \\equiv \u0026amp; y \u0026amp;\\text{其中}\\ x\\neq y \\\\\n(M_1\\ M_2)[x:=N] \u0026amp; \\equiv \u0026amp; (M_1[x:=N])(M_2[x:=N]) \u0026amp; \\\\\n(\\lambda x.M)[x:=N] \u0026amp; \\equiv \u0026amp; (\\lambda x.M) \u0026amp; \\\\\n(\\lambda y.M)[x:=N] \u0026amp;\\equiv\u0026amp; \\lambda y.(M[x:=N]) \u0026amp; \\text{其中} x\\neq y,\\text{且} x \\notin FV(M) \\lor y\\notin FV(N) \\\\\n(\\lambda y.M)[x:=N] \u0026amp;\\equiv\u0026amp; \\lambda z.(M[y:=z][x:=N]) \u0026amp; \\text{其中} x\\neq y,\\text{且} x \\in FV(M) \\land y\\in FV(N)\\text{，} \\\\\n\u0026amp; \u0026amp; \u0026amp; z\\text{为满足} y_n\\notin FV(M) \\land y_n\\notin FV(N) \\text{的，最小的}n\\text{对应的}y_n \\end{array} $$\n运算 $\\alpha$变换 $\\alpha$变换是约束变量的重命名。例如，下面的两个函数是等价的。形式参数$x$换成$y$是不影响函数的。\n function(x) { return x + 1; } function(y) { return y + 1; }   (lambda (x) (+ x 1)) (lambda (y) (+ y 1))     $\\alpha$等价($\\lambda$-equivalent)表示在$\\alpha$变换下保持等价的$\\lambda$表达式。\n$$\\dfrac{}{x =_{\\alpha} x} $$\n$$\\dfrac{M_1 =_{\\alpha} M_2 \\qquad N_1 =_{\\alpha}N_2}{M_1\\ M_2 =_{\\alpha} N_1\\ N_2}$$\n$$\\dfrac{M_1[x:=z] =_{\\alpha} M_2[y:=z] \\qquad z\\notin FV(M_1)\\cup FV(M_2) }{\\lambda x.M_1=_{\\alpha} \\lambda y.M_2}$$\n$\\beta$归约 $\\beta$归约描述的是实参替换形参的过程，即函数应用的展开运算。\n$$(\\lambda x.M)\\ N \\to_{\\beta} M[x := N]$$\n具有左侧部分的形式的表达式可称为$\\beta$可归约式（$\\beta$ redex, $\\beta$ reducible expression）。一个$\\lambda$表达式中，可能出现多个$\\beta$可归约式。按照下面的规则可以进行非确定的完全$\\beta$归约。（非确定指同时多个可归约式时，归约的顺序不确定）\n$$\\dfrac{}{(\\lambda x.M)\\ N \\to_{\\beta} M[x := N]}\\qquad\\qquad \\dfrac{M_1\\to_{\\beta}M_2}{M_1\\ N\\to_{\\beta}M_2\\ N}$$\n$$\\dfrac{M_1\\to_{\\beta}M_2}{\\lambda x.M_1\\to_{\\beta}\\lambda x.M_2}\\qquad\\qquad\\qquad\\qquad\\dfrac{N_1\\to_{\\beta}N_2}{M\\ N_1\\to_{\\beta}M\\ N_2}$$\n 一个$\\beta$可归约式，显然地直接进行归约操作。（左上） 应用中的函数部分或实参部分出现$\\beta$可归约式，则分别进行归约操作后再应用。（右） 抽象中的函数体出现$\\beta$可归约式，可以先对函数体归约操作。（左下）  不含$\\beta$可归约式的$\\lambda$项称为$\\beta$范式(normal form)。通过以上规则，反复进行$\\beta$归约后，可以得到$\\beta$范式。但是，并不是所有的$\\lambda$表达式都能归约到$\\beta$范式。例如： $$(\\lambda x.x\\ x)\\ (\\lambda x. x_ x) \\to_{\\beta} (\\lambda x.x\\ x)\\ (\\lambda x. x_ x)$$ 这个式子会$\\beta$归约到自身。它永远无法通过$\\beta$归约去掉所有的$\\beta$可归约式。\nChurch-Rosser定理表明，如果一个$\\lambda$式存在$\\beta$范式，则在$\\alpha$等价的意义下，$\\beta$范式是唯一的。不过值得注意的是，即便$\\beta$范式存在，并不意味着按任意顺序归约都能得到$\\beta$范式。例如：\n$$ \\begin{array}{rclcl} (\\lambda x.\\lambda y.x)\\ a\\ ((\\lambda x.x\\ x)\\ (\\lambda x.x\\ x)) \u0026amp;\\to_{\\beta} \u0026amp; ([a/x] (\\lambda y.x))\\ ((\\lambda x.x\\ x)\\ (\\lambda x.x\\ x)) \u0026amp; \\equiv \u0026amp; ((\\lambda y.a))\\ ((\\lambda x.x\\ x)\\ (\\lambda x.x\\ x)) \\\\\n\u0026amp;\\to_{\\beta} \u0026amp; ([((\\lambda x.x\\ x)\\ (\\lambda x.x\\ x))/y]a)\\ \u0026amp; \\equiv \u0026amp; a \\end{array} $$\n以上经过两次$\\beta$归约，可以得到$\\beta$范式为$a$。如果执意先归约$((\\lambda x.x\\ x)\\ (\\lambda x.x\\ x))$的部分，那便永远得不到$\\beta$范式了。可见不恰当的归约顺序会导致陷入循环，无法得到$\\beta$范式。\n$\\eta$变换 $\\eta$归约是$\\lambda$演算中外延性的描述。\n外延性（extensionality）  两个对象相等，当且仅当它们的属性都相等。\n 两个集合相等，当且仅当它们的元素相同。（外延公理）  形式定义：$\\forall P\\forall Q[\\forall X(X\\in P\\leftrightarrow X\\in Q) \\to P=Q]$   两个函数相等，当且仅当对任意给定的参数，函数值对应相等。（注意，这里并没有比较函数内部的逻辑，而仅仅从外面的输入/输出来判断）  $\\forall f\\forall g[\\forall x(f(x)=g(x))\\to f=g]$   两个$\\lambda$表达式相等，当且仅当应用到任意实参$x$时，两者相等。  $\\forall M\\forall N[\\forall x\\notin\\mathit{FV}(M)\\cup\\mathit{FV}(N)\\ (\\lambda x.M\\ x = \\lambda x.N\\ x)\\to M=N]$       $$\\dfrac{x\\notin \\mathit{FV}(M)}{\\lambda x.M\\ x \\to_{\\eta} M}$$\n($\\eta$变换$\\to$外延性) 若$f = g$，$x\\notin\\mathit{FV}(f)\\cup\\mathit{FV}(g)$，由$\\eta$变换，$\\lambda x.f\\ x = \\lambda x.g\\ x$成立。\n(外延性$\\to\\eta$变换) 若$(\\lambda x. f\\ x)\\ y = f\\ y$对任意的$y$成立。由外延性，$\\lambda x.f\\ x = f$成立。\n归约策略 当一个$\\lambda$式中有多个可归约项时，归约运算的顺序便是归约策略（reduction strategies）。主要有以下两大类\n 严格求值策略（strict evaluation strategy），也称及早求值（eager evaluation，又译热切求值），贪婪求值（greedy evaluation）。  无论参数在函数体中是否被使用，总是先对参数进行求值运算。   非严格求值策略（non-strict evaluation strategy），也称惰性求值（lazy evaluation，又译懒惰求值、惰性计算）。  当且仅当参数在函数体中被使用时，对该参数进行求值运算。     回顾可知，$\\beta$规约是$(\\lambda x.M) N \\to_{\\beta} M[x:=N] $。\n再假设$N$也是可规约式。以上两类求值策略，主要就是$N$是否要先于整个式子的$\\beta$规约进行规约计算。 先对$N$规约，则是严格求值策略；先对整个式子规约，则是非严格求值策略。\n 以下是C语言描述的例子\nint hello ( int parameter ) { printf (\u0026quot; Hello World !\u0026quot;) ; return 41; } int fac ( int n ) { if ( n == 0) return 1; else return n * fac ( n - 1) ; }   hello(fac(13)): 如果以惰性求值，因为fac(13)在函数hello中并未被使用，因此是不会被计算的。  惰性求值可以节省计算，提高效率。   hello(hello(0)): 如果以惰性求值，只会输出一个\u0026quot;Hello World!\u0026quot;，因为hello(0)在函数hello中并未被使用，因此不会被计算。  惰性求值对副作用（side effect）是不友好的。  函数hello的输入是整型的parameter，输出是整型常数41。而打印\u0026quot;Hello World!\u0026ldquo;是该函数的一个副作用。 在常见的命令式编程语言中，副作用是常见的；而函数式编程语言往往要求函数没有副作用，即纯函数。      非严格求值 正常次序 正常次序(Normal order)是一种非严格求值策略。正常次序是指从最左边，最外层的可规约式进行求值计算。例如\n$$ \\begin{array}{rl} \u0026amp; \\underline{(\\lambda x.x)((\\lambda x.x)(\\lambda z.(\\lambda w.w) z))} \\\\\n\\to_{\\beta} \u0026amp; \\underline{(\\lambda x.x)(\\lambda z.(\\lambda w.w) z)} \\\\\n\\to_{\\beta} \u0026amp; \\lambda z.\\underline{(\\lambda w.w) z} \\\\\n\\to_{\\beta} \u0026amp; \\lambda z.z \\quad \\nrightarrow\n\\end{array} $$\n如名字中“正常”两字所示，这是$\\lambda$计算默认的求值策略。\n传名调用 传名调用（Call by name）求值策略和正常次序求值策略是很类似的。但是，传名调用只针对函数应用，将形参不做求值直接替换到函数体内。如果一个函数未被应用，那么函数体中的可规约式不会被求值。例如：\n$$ \\begin{array}{rl} \u0026amp; \\underline{(\\lambda x.x)((\\lambda x.x)(\\lambda z.(\\lambda w.w) z))} \\\\\n\\to_{\\beta} \u0026amp; \\underline{(\\lambda x.x)(\\lambda z.(\\lambda w.w) z)} \\\\\n\\to_{\\beta} \u0026amp; \\lambda z.(\\lambda w.w) z \\quad \\nrightarrow\n\\end{array} $$\n最后一行是一个函数，其形参为$z$，函数体为$(\\lambda w.w) z$。函数未被应用，没有实参。传名调用求值策略的计算就到此为止了。函数体部分虽然有可规约式，却不会被计算求值了。这就是传名调用策略和正常次序策略的不同。\n传需求调用 传需求调用(Call by need)是传名调用的记忆化（memorized）版本。对于纯函数，同样的输入参数一定会得到同样的输入结果。因此，记忆化缓存计算结果，可以节省重复计算的开销，提高性能。对于有副作用的部分，Haskell语言采用Monad（单子），消除了值的改变优先于延迟运算的不确定性问题。\n  键盘读取值$x$，然后计算$\\sqrt{x}$。  这个是不纯的，因为$x$无法预测。   如果键盘读取值$x$，那么计算$\\sqrt{x}$。   传宏展开调用 传宏展开调用（Call by macro expansion）和传名调用是类似的。\n严格求值 应用序 按值调用 实例 邱奇编码 邱奇编码是把数据和运算符嵌入到lambda演算内的一种方式，方法得名于阿隆佐·邱奇。透过邱奇编码，在其他符号系统中通常被认定为基本的项（比如整数、布尔值、有序对、列表和tagged unions）都会被映射到高阶函数。在无型别lambda演算，函数是唯一的原始型别。\n邱奇数 在数学中，函数$f: X\\to Y$和$g: Y\\to Z$可以复合得到函数$g\\circ f: X\\to Z$，定义为$(g\\circ f)(x)=g(f(x))$。$n$重复合函数可以写成如下形式：\n$$f^{\\circ n}=\\underbrace{f\\circ f\\circ f \\circ \\cdots \\circ f}_{n\\text{个}}$$\n递归 "},{"uri":"https://book.cherrysky.org/programming/object-oriented-programming/sigma/","title":"2.1 $\\varsigma$演算","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/reactive-programming/examples/","title":"4.1 图说 响应式编程常用函数","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/introduction/","title":"第一章 基础概念","tags":null,"description":"","content":" 图灵机 $\\lambda$演算 一阶逻辑 时序逻辑MPTL 动态逻辑 petri网 进程代数 递归可枚举语言  "},{"uri":"https://book.cherrysky.org/programming/introduction/lambda/","title":"1.2 $\\lambda$演算","tags":null,"description":"","content":"$\\lambda$演算（英语：lambda calculus，$\\lambda$-calculus）是一套从数学逻辑中发展，以变量绑定和替换的规则，来研究函数如何抽象化定义、函数如何被应用以及递归的形式系统。它由数学家阿隆佐·邱奇在20世纪30年代首次发表。$\\lambda$演算作为一种广泛用途的计算模型，可以清晰地定义什么是一个可计算函数，而任何可计算函数都能以这种形式表达和求值，它能模拟单一磁带图灵机的计算过程；尽管如此，$\\lambda$演算强调的是变换规则的运用，而非实现它们的具体机器。\n$\\lambda$演算可比拟是最根本的编程语言，它包括了一条变换规则（变量替换）和一条将函数抽象化定义的方式。因此普遍公认是一种更接近软件而非硬件的方式。对函数式编程语言造成很大影响，比如Lisp、ML语言和Haskell语言。\n"},{"uri":"https://book.cherrysky.org/programming/introduction/lambda/typed/","title":"1.2.2 带类型$\\lambda$演算","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/reactive-programming/javascript/","title":"4.2 TypeScript语言","tags":null,"description":"","content":"Promise Generator函数 RxJS 以rxjs为例，它解决的是下表中Observable的部分。\n    单值 多值     拉取 Function Iterator   推送 Promise Observable    "},{"uri":"https://book.cherrysky.org/programming/object-oriented-programming/","title":"第二章 面向对象编程","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/introduction/lambda/calculator/","title":"1.2.3 $\\lambda$演算计算器","tags":null,"description":"","content":" 以下出自马萨里克大学（Masaryk University）的JAKUB KADLECAJ的本科学位论文，开源代码 https://gitlab.com/kdlcj/lambda，遵循CC0 1.0协议。为适合嵌入网页中动作行为，已经修改了某些跳转链接的target。   "},{"uri":"https://book.cherrysky.org/programming/reactive-programming/java/","title":"4.3 Java语言","tags":null,"description":"","content":"    单值 多值     拉取(同步) Function (迭代器/生成器)   推送(异步) CompletableFuture (流)    4.2.1 Function 函数 这个是最常见的语法，即当调用者调用一个函数时，同步地返回一个值。\n4.2.2 CompletableFuture Future Future是Java1.5引入的功能。它配合Callable或Runnable可以方便地实现异步调用。\nsequenceDiagram Main-ExecutorService: 提交Callable activate ExecutorService ExecutorService-+Thread-1: 创建线程，执行Callable ExecutorService--Main: 返回Future deactivate ExecutorService Main-Main: 其他任意工作 Main-Thread-1: Future.get() Thread-1---Main: 返回结果  要注意，Future.get()是阻塞的。如果调用者在实际任务未完成前就调用get，那就需要一直等待（当然，超时时间是可以设置的）。  import java.util.concurrent.*; public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException { // 线程 ExecutorService executorService = Executors.newSingleThreadExecutor(); Callable\u0026lt;String\u0026gt; callable = new Callable\u0026lt;String\u0026gt;() { @Override public String call() { // Perform some computation System.out.println(\u0026quot;Entered Callable\u0026quot;); Thread.sleep(2000); return \u0026quot;Hello from Callable\u0026quot;; } }; System.out.println(\u0026quot;Submitting Callable\u0026quot;); Future\u0026lt;String\u0026gt; future = executorService.submit(callable); // This line executes immediately System.out.println(\u0026quot;Do something else while callable is getting executed\u0026quot;); System.out.println(\u0026quot;Retrieve the result of the future\u0026quot;); // Future.get() blocks until the result is available String result = future.get(); System.out.println(result); executorService.shutdown(); } }    \n如果相互依赖的连续多个异步调用该如何处理？例如，异步函数B需要异步函数A的返回值。若使用上述Future来实现，那么，\n Main线程就要等待异步函数A结束，get到其结果，然后再调用异步函数B； 又或者，异步函数A里面以回调（callback）方式嵌入异步函数B的逻辑。  第一个方案如下：\nsequenceDiagram Main-ExecutorService: 提交Callable A activate ExecutorService ExecutorService-+Thread-1: 创建线程，执行Callable A ExecutorService--Main: 返回Future deactivate ExecutorService Main-Main: 其他任意工作 Main-Thread-1: Future.get() Thread-1---Main: 返回结果 Main-+ExecutorService: 提交Callable B ExecutorService-+Thread-1: 创建线程，执行Callable B ExecutorService--Main: 返回Future deactivate ExecutorService Main-Main: 其他任意工作 Main-Thread-1: Future.get() Thread-1---Main: 返回结果  第二方案中，由于Callable的call()方法或者Runnable的run()方法都是不接受参数的，因此需要自定义拓展接口。当然，很多第三方库都有提供类似的功能。\n下面代码演示了在一个异步调用中发起另一个异步调用的情况。\nsequenceDiagram Main-ExecutorService: 提交Callable 1 activate ExecutorService ExecutorService-+Thread-1: 创建线程，执行Callable 1 ExecutorService--Main: 返回Future deactivate ExecutorService Thread-1-+ExecutorService: 提交Callable 2 Main-Main: 其他任意工作 ExecutorService-+Thread-2: 创建线程，执行Callable 2 ExecutorService---Thread-1: 返回Future Thread-1-Thread-1: 其他任意工作 Thread-1-Thread-2: Future.get() Thread-2---Thread-1: 返回结果 Main-Thread-1: Future.get() Thread-1---Main: 返回结果  Callback.java为拓展的Callable，内含一个callback变量可以传入一个回调函数。回调函数可以向其中插入一段逻辑。\n import java.util.concurrent.*; import java.util.Locale; public class Main { private static abstract class Callback\u0026lt;T, S\u0026gt; implements Callable\u0026lt;S\u0026gt; { T callback; void setCallback (T callback) { this.callback = callback; } public abstract S call () throws Exception; } public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newFixedThreadPool(2); Callback\u0026lt;String, String\u0026gt; upperCase = new Callback\u0026lt;String, String\u0026gt;() { public String call() throws Exception { System.out.println(\u0026quot;Entered Callable 2\u0026quot;); Thread.sleep(2000); return callback.toUpperCase(Locale.forLanguageTag(\u0026quot;en\u0026quot;)); } }; Callback\u0026lt;Callback\u0026lt;String, String\u0026gt;, String\u0026gt; callable = new Callback\u0026lt;Callback\u0026lt;String, String\u0026gt;, String\u0026gt;() { public String call() throws Exception { // Perform some computation System.out.println(\u0026quot;Entered Callable 1\u0026quot;); Thread.sleep(2000); // return \u0026quot;Hello from Callable 1\u0026quot;; System.out.println(\u0026quot;Submitting Callback\u0026quot;); // 一个值，也是一个特殊的回调函数，可视作常函数。 callback.setCallback(\u0026quot;Hello from Callable 1\u0026quot;); Future\u0026lt;String\u0026gt; future = executorService.submit(callback); return future.get(); } }; callable.setCallback(upperCase); System.out.println(\u0026quot;Submitting Callable\u0026quot;); Future\u0026lt;String\u0026gt; future = executorService.submit(callable); // This line executes immediately System.out.println(\u0026quot;Do something else while callable is getting executed\u0026quot;); System.out.println(\u0026quot;Retrieve the result of the future\u0026quot;); // Future.get() blocks until the result is available String result = future.get(); System.out.println(result); executorService.shutdown(); } }   import java.util.concurrent.*; // Callback是一个相对独立的\u0026quot;计算单元\u0026quot;，它可以被放到一个线程中去执行，待执行结束后再查看结果即可。 // 它包含两块逻辑: // 一个是call部分，为自身的逻辑 // 另一个是callback部分，即调用者向该\u0026quot;计算单元\u0026quot;中注入的逻辑 public abstract class Callback\u0026lt;T, S\u0026gt; implements Callable\u0026lt;S\u0026gt; { // 回调处理，以便在call函数中利用 T callback; // 添加回调函数 void setCallback (T callback) { this.callback = callback; } public abstract S call () throws Exception; }     CompletableFuture CompletableFuture是Java1.8引入的功能。同时，Java1.8还加入了java.util.function.*的函数接口，以及lambda函数的语法。\n import java.util.concurrent.*; import java.util.function.*; import java.util.Locale; public class Main { public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newFixedThreadPool(2); System.out.println(\u0026quot;Submitting Async Task\u0026quot;); CompletableFuture\u0026lt;Either\u0026lt;String, Exception\u0026gt;\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { try{ // Perform some computation System.out.println(\u0026quot;Entered Callable 1\u0026quot;); Thread.sleep(2000); return Either.\u0026lt;String, Exception\u0026gt;left(\u0026quot;Hello from Callable 1\u0026quot;); } catch (Exception e) { return Either.\u0026lt;String, Exception\u0026gt;right(e); } }, executorService).\u0026lt;Either\u0026lt;String, Exception\u0026gt;\u0026gt;thenApplyAsync((Either\u0026lt;String, Exception\u0026gt; result)-\u0026gt;{ return result.\u0026lt;String, Exception\u0026gt;flatMap((String s) -\u0026gt; { try { System.out.println(\u0026quot;Entered Callable 2\u0026quot;); Thread.sleep(2000); return Either.left(s.toUpperCase(Locale.forLanguageTag(\u0026quot;en\u0026quot;))); } catch (Exception e) { return Either.\u0026lt;String, Exception\u0026gt;right(e); } }, e -\u0026gt; Either.\u0026lt;String, Exception\u0026gt;right(e)); }, executorService); // This line executes immediately System.out.println(\u0026quot;Do something else while callable is getting executed\u0026quot;); System.out.println(\u0026quot;Retrieve the result of the future\u0026quot;); // Future.get() blocks until the result is available future.\u0026lt;Either\u0026lt;String, Exception\u0026gt;\u0026gt;get().apply((String s) -\u0026gt; { System.out.println(s); }, e -\u0026gt; { // System.out.println(\u0026quot;Exception:\u0026quot; + e.getMessage()); }); executorService.shutdown(); } }   import java.util.function.*; public abstract class Either\u0026lt;L,R\u0026gt; { public static \u0026lt;L,R\u0026gt; Either\u0026lt;L,R\u0026gt; left(L value) { return new Either\u0026lt;L,R\u0026gt;() { @Override public \u0026lt;T\u0026gt; T map(Function\u0026lt;? super L, ? extends T\u0026gt; lFunc, Function\u0026lt;? super R, ? extends T\u0026gt; rFunc) { return lFunc.apply(value); } @Override public \u0026lt;A, B\u0026gt; Either\u0026lt;A, B\u0026gt; flatMap(Function\u0026lt;L, Either\u0026lt;A, B\u0026gt;\u0026gt; toLeft, Function\u0026lt;R, Either\u0026lt;A, B\u0026gt;\u0026gt; toRight) { return toLeft.apply(value); } }; } public static \u0026lt;L,R\u0026gt; Either\u0026lt;L,R\u0026gt; right(R value) { return new Either\u0026lt;L,R\u0026gt;() { @Override public \u0026lt;T\u0026gt; T map(Function\u0026lt;? super L, ? extends T\u0026gt; lFunc, Function\u0026lt;? super R, ? extends T\u0026gt; rFunc) { return rFunc.apply(value); } @Override public \u0026lt;A, B\u0026gt; Either\u0026lt;A, B\u0026gt; flatMap(Function\u0026lt;L, Either\u0026lt;A, B\u0026gt;\u0026gt; toLeft, Function\u0026lt;R, Either\u0026lt;A, B\u0026gt;\u0026gt; toRight) { return toRight.apply(value); } }; } private Either() {} public abstract \u0026lt;T\u0026gt; T map( Function\u0026lt;? super L, ? extends T\u0026gt; lFunc, Function\u0026lt;? super R, ? extends T\u0026gt; rFunc); public \u0026lt;T\u0026gt; Either\u0026lt;T,R\u0026gt; mapLeft(Function\u0026lt;? super L, ? extends T\u0026gt; lFunc) { return this.\u0026lt;Either\u0026lt;T,R\u0026gt;\u0026gt;map(t -\u0026gt; left(lFunc.apply(t)), t -\u0026gt; (Either\u0026lt;T,R\u0026gt;)this); } public \u0026lt;T\u0026gt; Either\u0026lt;L,T\u0026gt; mapRight(Function\u0026lt;? super R, ? extends T\u0026gt; lFunc) { return this.\u0026lt;Either\u0026lt;L,T\u0026gt;\u0026gt;map(t -\u0026gt; (Either\u0026lt;L,T\u0026gt;)this, t -\u0026gt; right(lFunc.apply(t))); } public void apply(Consumer\u0026lt;? super L\u0026gt; lFunc, Consumer\u0026lt;? super R\u0026gt; rFunc) { map(consume(lFunc), consume(rFunc)); } private \u0026lt;T\u0026gt; Function\u0026lt;T, Void\u0026gt; consume(Consumer\u0026lt;T\u0026gt; c) { return t -\u0026gt; { c.accept(t); return null; }; } public abstract \u0026lt;A, B\u0026gt; Either\u0026lt;A, B\u0026gt; flatMap( Function\u0026lt;L, Either\u0026lt;A, B\u0026gt;\u0026gt; toLeft, Function\u0026lt;R, Either\u0026lt;A, B\u0026gt;\u0026gt; toRight); }     4.2.3 迭代器・生成器 Java默认是不支持一个函数有多个返回值的。多个返回值不是指一次性返回超过一个值，而是指沿时间序列，不断发送返回值。\n有些编程语言如Python允许一次性返回超过一个值，其实相当于返回一个元组（tuple）一样，相当于一个值。   import java.util.concurrent.*; import java.util.Iterator; public class Main { // 求所有n的倍数 private static Generator\u0026lt;Integer\u0026gt; multiplesOf(int n) { // 该函数返回值有无穷个整数 return new Generator\u0026lt;Integer\u0026gt;() { public void run() throws InterruptedException { int i = 0; while (true) { yield(n*(i++)); } } }; } public static void main(String[] args) throws InterruptedException, ExecutionException { // 求7的倍数 Iterator\u0026lt;Integer\u0026gt; result = multiplesOf(7).iterator(); // 显示前4个 System.out.println(result.next()); System.out.println(result.next()); System.out.println(result.next()); System.out.println(result.next()); } }   import java.util.Iterator; import java.util.NoSuchElementException; public abstract class Generator\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private class Condition { private boolean isSet; public synchronized void set() { isSet = true; notify(); } public synchronized void await() throws InterruptedException { try { if (isSet) return; wait(); } finally { isSet = false; } } } static ThreadGroup THREAD_GROUP; Thread producer; private boolean hasFinished; private final Condition itemAvailableOrHasFinished = new Condition(); private final Condition itemRequested = new Condition(); private T nextItem; private boolean nextItemAvailable; private RuntimeException exceptionRaisedByProducer; @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new Iterator\u0026lt;T\u0026gt;() { @Override public boolean hasNext() { return waitForNext(); } @Override public T next() { if (!waitForNext()) throw new NoSuchElementException(); nextItemAvailable = false; return nextItem; } @Override public void remove() { throw new UnsupportedOperationException(); } private boolean waitForNext() { if (nextItemAvailable) return true; if (hasFinished) return false; if (producer == null) startProducer(); itemRequested.set(); try { itemAvailableOrHasFinished.await(); } catch (InterruptedException e) { hasFinished = true; } if (exceptionRaisedByProducer != null) throw exceptionRaisedByProducer; return !hasFinished; } }; } protected abstract void run() throws InterruptedException; protected void yield(T element) throws InterruptedException { nextItem = element; nextItemAvailable = true; itemAvailableOrHasFinished.set(); itemRequested.await(); } private void startProducer() { assert producer == null; if (THREAD_GROUP == null) THREAD_GROUP = new ThreadGroup(\u0026quot;generatorfunctions\u0026quot;); producer = new Thread(THREAD_GROUP, new Runnable() { @Override public void run() { try { itemRequested.await(); Generator.this.run(); } catch (InterruptedException e) { // No need to do anything here; Remaining steps in run() // will cleanly shut down the thread. } catch (RuntimeException e) { exceptionRaisedByProducer = e; } hasFinished = true; itemAvailableOrHasFinished.set(); } }); producer.setDaemon(true); producer.start(); } @Override protected void finalize() throws Throwable { producer.interrupt(); producer.join(); super.finalize(); } }     4.2.4 流   第三方库 多值 单值 备考     Reactor Flux Mono Spring WebFlux响应式框架的基础   RxJava Observable Single ReactiveX项目的Java版     函数的输入输出按照值的个数被包装了起来。它们都是异步的。以Reactor为例，\n Mono\u0026lt;Integer\u0026gt;: 一个整数值会到来。它本身不是整数值，但它描述了整数值会到来这件事情。 Flux\u0026lt;Integer\u0026gt;: 一系列整数值会到来。同样的，它是一个事件。拿到这个事件后，可以定义当每个值到来时如何处理，也可以对事件整体进行处理。  public Flux\u0026lt;Integer\u0026gt; example(Flux\u0026lt;Integer\u0026gt; input) { return input .map(x -\u0026gt; x^2) .buffer(2) .map(x -\u0026gt; x.size()); }   [styles] event_radius = 30 operator_height = 60 ----1----2----3----4---5-|  map(x - x^2) ----A-----B-----C--D----E-| A := 1 B := 4 C := 9 D := 16 E := 25  buffer(2) -----------X--------Y----Z-| X := [1,4] Y := [9,16] Z := [25]  map(x-x.size()) -----------2---------2----1-|   4.2.5 例: Spring WebFlux Spring WebFlux框架将客户端的请求（request）视作流入的起点，在服务端经过运算后，再源源不断地流向客户，响应（response）请求。这是一个符合人们印象的很自然的抽象。它与传统Spring框架的最大不同是，它的异步性。\n从思想上讲，\n 传统的Spring框架：当服务器收到用户请求数据X时，对X如何处理。 Spring WebFlux框架：当服务器收到用户请求数据X这件事E发生时，如何对该事件E处理。  当然，由于HTTP的局限性，用户请求数据都是简单的，即框架底层会将数据同步之后，再传输。例如向客户端响应一个Flux并不意味着向客户端源源不断地发送多次HTTP响应，而是框架底层会收集Flux的数据后，统一发往客户端。同样的，客户端的请求数据也不可能是源源不断的Flux，WebFlux框架甚至没对它抽象。\n一个节选自官网的例子。\nhttps://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn-handler-functions\nimport static org.springframework.http.MediaType.APPLICATION_JSON; import static org.springframework.web.reactive.function.server.ServerResponse.ok; public class PersonHandler { private final PersonRepository repository; public PersonHandler(PersonRepository repository) { this.repository = repository; } public Mono\u0026lt;ServerResponse\u0026gt; listPeople(ServerRequest request) { Flux\u0026lt;Person\u0026gt; people = repository.allPeople(); return ok().contentType(APPLICATION_JSON).body(people, Person.class); } public Mono\u0026lt;ServerResponse\u0026gt; createPerson(ServerRequest request) { Mono\u0026lt;Person\u0026gt; person = request.bodyToMono(Person.class); return ok().build(repository.savePerson(person)); } public Mono\u0026lt;ServerResponse\u0026gt; getPerson(ServerRequest request) { int personId = Integer.valueOf(request.pathVariable(\u0026quot;id\u0026quot;)); return repository.getPerson(personId) .flatMap(person -\u0026gt; ok().contentType(APPLICATION_JSON).bodyValue(person)) .switchIfEmpty(ServerResponse.notFound().build()); } }  4.2.6 例: reactive-grpc (Salesforce) gRPC的通信模式完美契合Reactive框架的数据抽象。\ngRPC的四种情况：\n 一对一（unary）：一个请求，一个响应 一对多（server stream）：一个请求，多次响应 多对一（client stream）：多个请求，一次响应 多对多（bi-direction stream）：多次请求，多次响应  对于单值、多值传递这件事，ReactiveX框架恰好有Mono和Flux可以描述。\n节选自官网的例子：\nhttps://github.com/salesforce/reactive-grpc/tree/master/reactor\nReactorGreeterGrpc.GreeterImplBase svc = new ReactorGreeterGrpc.GreeterImplBase() { @Override public Mono\u0026lt;HelloResponse\u0026gt; sayHello(Mono\u0026lt;HelloRequest\u0026gt; request) { return request.map(protoRequest -\u0026gt; greet(\u0026quot;Hello\u0026quot;, protoRequest)); } ... @Override public Flux\u0026lt;HelloResponse\u0026gt; sayHelloBothStream(Flux\u0026lt;HelloRequest\u0026gt; request) { return request .map(HelloRequest::getName) .buffer(2) .map(names -\u0026gt; greet(\u0026quot;Hello\u0026quot;, String.join(\u0026quot; and \u0026quot;, names))); } };  "},{"uri":"https://book.cherrysky.org/programming/functional-programming/","title":"第三章 函数式编程","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/introduction/categeroy/","title":"1.4 范畴论","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/reactive-programming/","title":"第四章 响应式编程","tags":null,"description":"","content":"响应式编程是一种声明式编程。例如，Excel的单元格就是一个例子。单元格可以包含字面值或类似=B1+C1的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。因此，响应式编程的重点是考虑数据流的变化和传播。\n概述 一个函数 $f(x)=x^2$ ，它可以由下图表示。\nCode could not finish, this are some reasons why this happen. - Plot name not defined. The first parameter of the shortcode is the name. - There is a syntax error. check browser console.   function draw() { test = document.getElementById(\"$f(x)=x^2$\"); if (test == null) { console.log(\"The plot name is not defined\") return } fig = null fig = { \"data\":[{ x: [0, 1, 2, 3, 4], y: [0, 1, 4, 9, 16], type: \"scatter\" }], \"layout\":{ \"margin\":{\"l\":25,\"r\":5,\"b\":75,\"t\":50,\"pad\":4} }, \"config\":{\"responsive\":true} } if (!fig) { test.innerText = \"ERROR: fig variable is not defined\" return } test.innerText = null Plotly.plot(test, fig); } draw()   也可以由下图表示。\n ----1----2----3----4----|  $f(x)=x^2$ ----A-----B-----C--D-----| A := 1 B := 4 C := 9 D := 16   一个是二维平面空间上的点，一个是一维时间上的事件。\n计算机程序可以抽象成数据的流动。每次数据变换都是一个函数，可以视为一个\u0026quot;反应堆\u0026quot;（reactor）。数据在反应堆之间多次传递之后，就完成了从输入到输出的整个过程。\n在数据流动过程中，有两种操作：\n 数据流动的形态和方向 数据本身的变化  目前，响应式编程的函数库或框架解决的是前者。例如将两个流合成一个流，例如将一个流变为另一个流。\n"},{"uri":"https://book.cherrysky.org/programming/test/","title":"语法测试页","tags":null,"description":"","content":"复杂表格   A B C D     \u0026lt;! row3 \u0026gt; A \u0026lt;! col2 \u0026gt; B \u0026hellip; \u0026lt;! row2 \u0026gt; D   \u0026hellip; \u0026lt;! row2 \u0026gt; B C \u0026hellip;   \u0026hellip; \u0026hellip; \u0026lt;! col2 \u0026gt; C \u0026hellip;     数学公式 $$x(l)=\\int_0^l{\\cos{\\frac{\\theta^2}{2}}d\\theta}, y(l)=\\int_0^l{\\sin{\\frac{\\theta^2}{2}}d\\theta}$$\n多页面区域 代码高亮  #include \u0026lt;stdio.h\u0026gt;\rint main(int argc, char *argv[])\r{\rprintf(\u0026quot;Hello World\\n\u0026quot;);\rreturn 0;\r}\r \rprint \u0026quot;Hello World\u0026quot;\r \r  时序图等 sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-John: Hello John, how are you?\rloop Healthcheck\rJohn-John: Fight against hypochondria\rend\rNote right of John: Rational thoughts prevail!\rJohn--Alice: Great!\rJohn-Bob: How about you?\rBob--John: Jolly good!\r 流程图 \rst=start: Start|past:http://www.google.com[blank]\re=end: End|future:http://www.google.com\rop1=operation: My Operation|past\rop2=operation: Stuff|current\rsub1=subroutine: My Subroutine|invalid\rcond=condition: Yes\ror No?|approved:http://www.google.com\rc2=condition: Good idea|rejected\rio=inputoutput: catch something...|future\rst-op1(right)-cond\rcond(yes, right)-c2\rcond(no)-sub1(left)-op1\rc2(yes)-io-e\rc2(no)-op2-e\r  算法 % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)\r\\begin{algorithm}\r\\caption{Quicksort}\r\\begin{algorithmic}\r\\PROCEDURE{Quicksort}{$A, p, r$}\r\\IF{$p 链珠图 \r% An example application of the concatAll operator.\r% Edit this code to redraw the diagram in real time.\rx = ----a------b------|\ry = ---c-d---|\rz = ---e--f-|\r-x---y----z------|\r concatAll $f(x)\\to 2^x$\r-----a------b---------c-d------e--f-|\r  代码高亮 终端 窗口风格 x  \u0026ndash;  +   bash~  ls -l .\r    .window { background: #fff; width: 65vw; max-width: 800px; min-width: 360px; margin: auto; margin-top: 3.5vh; margin-bottom: 3.5vh; border: 1px solid #acacac; border-radius: 6px; box-shadow: 0px 0px 20px #acacac; } .window a { text-decoration: none; pointer-events: none; } .titlebar { background: -webkit-gradient(linear, left top, left bottom, color-stop(0.0, #ebebeb, color-stop(1.0, #d5d5d5))); background: -webkit-linear-gradient(top, #ebebeb, #d5d5d5); background: -moz-linear-gradient(top, #ebebeb, #d5d5d5); background: -ms-linear-gradient(top, #ebebeb, #d5d5d5); background: -o-linear-gradient(top, #ebebeb, #d5d5d5); background: linear-gradient(top, #ebebeb, #d5d5d5); color: #4d494d; font-size: 11pt; line-height: 22px; text-align: center; width: 100%; height: 22px; border-top: 1px solid #f3f1f3; border-bottom: 1px solid #b1aeb1; border-top-left-radius: 6px; border-top-right-radius: 6px; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; cursor: default; } .buttons { padding-left: 8px; padding-top: 5px; float: left; line-height: 0px; } .buttons:hover a { visibility: visible; } .bclose { background: #ff5c5c; font-size: 9pt; line-height: 11px; margin-left: 4px; width: 11px; height: 11px; border: 1px solid #e33e41; border-radius: 50%; float: left; display: inline-block; } .bclose:active { background: #c14645; border: 1px solid #b03537; } .bclose:active .closebutton { color: #4e0002; } .closebutton { color: #820005; visibility: hidden; cursor: default; } .minimize { background: #ffbd4c; font-size: 9pt; line-height: 11px; margin-left: 8px; width: 11px; height: 11px; border: 1px solid #e09e3e; border-radius: 50%; display: inline-block; } .minimize:active { background: #c08e38; border: 1px solid #af7c33; } .minimize:active .minimizebutton { color: #5a2607; } .minimizebutton { color: #9a5518; visibility: hidden; cursor: default; } .zoom { background: #00ca56; font-size: 9pt; line-height: 11px; margin-left: 4px; width: 11px; height: 11px; border: 1px solid #14ae46; border-radius: 50%; display: inline-block; } .zoom:active { background: #029740; border: 1px solid #128435; } .zoom:active .zoombutton { color: #003107; } .zoombutton { color: #006519; visibility: hidden; cursor: default; } .terminal { margin: 0; list-style: none; -webkit-border-bottom-right-radius: 3px; -webkit-border-bottom-left-radius: 3px; -moz-border-radius-bottomright: 3px; -moz-border-radius-bottomleft: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; } .terminal .command-line { margin: 0; -webkit-border-bottom-right-radius: 4px; -webkit-border-bottom-left-radius: 4px; -moz-border-radius-bottomright: 4px; -moz-border-radius-bottomleft: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; } .terminal .toolbar { display: none; }  代码块风格 Get-Location\r(out)\r(out)Path\r(out)----\r(out)D:\\code_at_blog\\prism\r "},{"uri":"https://book.cherrysky.org/programming/categories/","title":"Categories","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/tags/","title":"Tags","tags":null,"description":"","content":""},{"uri":"https://book.cherrysky.org/programming/","title":"编程语言学习笔记","tags":null,"description":"","content":"笔记\n"}]