<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><base href=https://book.cherrysky.org/programming/><link rel=canonical href=https://book.cherrysky.org/programming/introduction/lambda/untyped/><title>1.2.1 无类型$\lambda$演算 | 编程语言笔记</title><link rel=stylesheet href=/programming/css/prism-tomorrownight.min.css><link href=https://book.cherrysky.org/programming/css/fontawesome.min.css rel=stylesheet><link rel=stylesheet href=https://book.cherrysky.org/programming/css/ace.min.css><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});MathJax.Hub.Config({TeX:{equationNumbers:{autoNumber:"AMS"}}});</script><link rel=stylesheet type=text/css href=https://book.cherrysky.org/programming/css/mathjax-style.css><script src=/programming/js/prism-tomorrownight.min.js></script></head><body><nav class="navbar navbar-expand-lg navbar-dark bg-primary shadow sticky-top" id=navbarMain><div class=container><div><a class=navbar-brand href=/programming>编程语言笔记</a></div><button class="navbar-toggler navbar-toggler-right collapsed" type=button data-toggle=collapse data-target=#navbarMainCollapse aria-controls=navbarMainCollapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarMainCollapse><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://github.com/lhttjdr/programming/releases target=_blank><button class="btn btn-success mt-n1">下载</button></a></li></ul></div></div></nav><div class=container-fluid><div class=row><div class="docs-sidenav order-0 col-12 col-md-3 col-lg-2 col-xl-2 position-sticky border-right"><nav class="navbar navbar-expand-md navbar-light pl-0"><button class="navbar-toggler navbar-toggler-right collapsed" type=button data-toggle=collapse data-target=#sidenav-left-collapse aria-controls=sidenav-left-collapse aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse align-items-start flex-column" id=sidenav-left-collapse><form class="form-inline my-2 my-lg-0 searchbox"><input class="form-control mr-sm-2 w-100" data-search-input id=search-by type=text placeholder=Search></form><ul class="navbar-nav flex-column pt-3"><li data-nav-id=/programming/introduction/ class="nav-item my-1 parent haschildren"><a class="nav-link p-0" href=/programming/introduction/><h6>第一章 基础概念</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/programming/introduction/turing-machine/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/programming/introduction/turing-machine/><h6>1.1 图灵机</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/programming/introduction/turing-machine/turing_machine/ class="nav-item my-1"><a href=/programming/introduction/turing-machine/turing_machine/ class="nav-link p-0">1.1.1 图灵机</a></li></ul></li><li data-nav-id=/programming/introduction/lambda/ class="nav-item my-1 parent haschildren"><a class="nav-link p-0" href=/programming/introduction/lambda/><h6>1.2 $\lambda$演算</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/programming/introduction/lambda/untyped/ class="nav-item my-1 active"><a href=/programming/introduction/lambda/untyped/ class="nav-link p-0">1.2.1 无类型$\lambda$演算</a></li><li data-nav-id=/programming/introduction/lambda/typed/ class="nav-item my-1"><a href=/programming/introduction/lambda/typed/ class="nav-link p-0">1.2.2 带类型$\lambda$演算</a></li><li data-nav-id=/programming/introduction/lambda/calculator/ class="nav-item my-1"><a href=/programming/introduction/lambda/calculator/ class="nav-link p-0">1.2.3 $\lambda$演算计算器</a></li></ul></li><li data-nav-id=/programming/introduction/categeroy/ class="nav-item my-1"><a class="nav-link p-0" href=/programming/introduction/categeroy/><h6>1.4 范畴论</h6></a></li></ul></li><li data-nav-id=/programming/object-oriented-programming/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/programming/object-oriented-programming/><h6>第二章 面向对象编程</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/programming/object-oriented-programming/sigma/ class="nav-item my-1"><a href=/programming/object-oriented-programming/sigma/ class="nav-link p-0">2.1 $\varsigma$演算</a></li></ul></li><li data-nav-id=/programming/functional-programming/ class="nav-item my-1"><a class="nav-link p-0" href=/programming/functional-programming/><h6>第三章 函数式编程</h6></a></li><li data-nav-id=/programming/reactive-programming/ class="nav-item my-1 haschildren"><a class="nav-link p-0" href=/programming/reactive-programming/><h6>第四章 响应式编程</h6></a><ul class="list-unstyled ml-2"><li data-nav-id=/programming/reactive-programming/examples/ class="nav-item my-1"><a href=/programming/reactive-programming/examples/ class="nav-link p-0">4.1 图说 响应式编程常用函数</a></li><li data-nav-id=/programming/reactive-programming/javascript/ class="nav-item my-1"><a href=/programming/reactive-programming/javascript/ class="nav-link p-0">4.2 TypeScript语言</a></li><li data-nav-id=/programming/reactive-programming/java/ class="nav-item my-1"><a href=/programming/reactive-programming/java/ class="nav-link p-0">4.3 Java语言</a></li></ul></li><li data-nav-id=/programming/test/ class="nav-item my-1"><a class="nav-link p-0" href=/programming/test/><h6>语法测试页</h6></a></li></ul></div></nav></div><div class="docs-toc large order-lg-2 order-md-0 order-xs-1 col-12 col-lg-2 col-xl-2 position-sticky border-left"><div><nav id=TableOfContents><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#无类型lambda演算>无类型$\lambda$演算</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#lambda表达式>$\lambda$表达式</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#概念>概念</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#自由变量与约束变量>自由变量与约束变量</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#新鲜变量>新鲜变量</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#组合子>组合子</a></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#变量替换>变量替换</a></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#运算>运算</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#alpha变换>$\alpha$变换</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#beta归约>$\beta$归约</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#eta变换>$\eta$变换</a></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#归约策略>归约策略</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#非严格求值>非严格求值</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#正常次序>正常次序</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#传名调用>传名调用</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#传需求调用>传需求调用</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#传宏展开调用>传宏展开调用</a></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#严格求值>严格求值</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#应用序>应用序</a></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#按值调用>按值调用</a></li></ul></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#实例>实例</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#邱奇编码>邱奇编码</a><ul><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#邱奇数>邱奇数</a></li></ul></li><li><a href=https://book.cherrysky.org/programming/introduction/lambda/untyped/#递归>递归</a></li></ul></li></ul></nav></div></div><div class="main col-12 order-1 col-md-9 col-lg-10 col-xl-8 py-3"><h1>1.2.1 无类型$\lambda$演算</h1><h2 id=无类型lambda演算>无类型$\lambda$演算</h2><h3 id=lambda表达式>$\lambda$表达式</h3><p>无歧义地定义一系列元素，构成可数集合，记$\mathit{VAR}$。对任意的$x \in \mathit{VAR}$，$\lambda$表达式$M$可以递归地定义如下：</p><ul><li>(变量, variable) 变量$x$为一个$\lambda$<strong>表达式</strong>。</li><li>(函数应用, application) 若$M$和$N$为$\lambda$表达式，则$(M\ N)$为$\lambda$表达式。</li><li>(函数抽象, abstraction) 若$x$为变量，$M$为lambda表达式，则$(\lambda x.M)$为$\lambda$表达式。</li></ul><p>从$\mathit{VAR}$产生的所有的$\lambda$表达式构成的集合是一种<strong>形式语言</strong>，记为$\Lambda$。</p><p>使用BNF范式，可写成
$$
\def\wideOr{\mathrel{\,\,|\,}}
\begin{array}{lcll}
M & ::= & x & \text{(变量, variable)} \\<br>& \wideOr & (\lambda x.M) & \text{(抽象, abstraction)} \\<br>& \wideOr & (M\ M) & \text{(应用, application)}
\end{array} $$</p><p>$\lambda$表达式的各部分名称如下:</p><p>$$ \displaystyle{
(\overbrace{(\lambda \underbrace{w}_\text{形式参数, parameter}.\underbrace{(w\ w)}_\text{函数体,function body})}^\text{函数, function} \overbrace{(\lambda o.(o\ o))}^\text{实际参数, argument})}
$$</p><p>通过如下语法约定，可以减少括号的使用
$$
\begin{eqnarray}
\lambda x_1 x_2 x_3\cdots x_n . M & \equiv & (\lambda x_1.(\lambda x_2.(\lambda x_3.(\cdots (\lambda x_n.M)\cdots)))) \nonumber \\<br>M_1\ M_2\ M_3 \cdots\ M_n & \equiv & (\cdots ((M_1\ M_2)\ M_3) \cdots\ M_n) \nonumber \\<br>\lambda x.M_1\ M_2\ M_3 \cdots\ M_n &\equiv & (\lambda x.(M_1\ M_2\ M_3 \cdots\ M_n)) \nonumber
\end{eqnarray}
$$
前两条描述的是结合性：函数抽象是右结合的（right-associative），函数应用是左结合的（left-associative）。最后一条描述的是优先级：函数应用的优先级高于函数抽象。</p><h3 id=概念>概念</h3><h4 id=自由变量与约束变量>自由变量与约束变量</h4><p>一个$\lambda$表达式的自由变量(free variable)由映射$FV : \Lambda \to { \mathit{VAR} }$来定义。
$$
\begin{array}{rcl}
FV(x) & = & \{x\} \\<br>FV(M\ N) &=& FV(M) \cup FV(N) \\<br>FV(\lambda x.M) &=& FV(M) \setminus \{x\} \\<br>\end{array}
$$
若变量出现在$\lambda$表达式中，且不是自由变量，则称为约束变量(bounded variable)。形式化定义如下,
$$
\begin{array}{rcl}
BV(y) & = & \{\} \\<br>BV(M\ N) &=& BV(M) \cup BV(N) \\<br>BV(\lambda y.M) &=& BV(M) \cup \{y\} \\<br>\end{array}
$$</p><h4 id=新鲜变量>新鲜变量</h4><p>既不是自由变量也不是约束变量的称为新鲜变量(fresh variable). 对于$\lambda$表达式$M$, $Fresh(M)$表示了全集$\mathit{VAR}$中$FV(M)\cup BV(M)$的补集。
$$\mathit{Fresh}(M) = \{x\in \mathit{VAR} | x\notin FV(M) \cup BV(M) \}$$</p><h4 id=组合子>组合子</h4><p>若$\lambda$表达式$M$满足$FV(M)=\{\}$，则称$M$为组合子（combinator）。</p><h3 id=变量替换>变量替换</h3><p>变量替换（substitution）是$\lambda$的基本操作。</p><p>以$N$替换$M$中的变量$x$,其结果记为$M[x:=N]$,也写作$[x/N]M$.
$$
\begin{array}{rcl}
y[x:=N] & \equiv & \begin{cases}
N\hphantom{NNNNNNNN}\hphantom{\lambda y.M} & \text{当} x=y \\<br>y & \text{其它}
\end{cases} \\<br>(M_1\ M_2)[x:=N] & \equiv & (M_1[x:=N])(M_2[x:=N]) \\<br>(\lambda y.M)[x:=N] & \equiv & \begin{cases}
\lambda y.M \hphantom{NNNNNNNN}\hphantom{N} & \text{当} x=y \\<br>\lambda y.M[x:=N] & \text{当} x\neq y \land (x\notin FV(M) \lor y\notin FV(N)) \\<br>\lambda z.M[y:=z][x:=N] & \text{其它; 其中}z\text{为第一个满足条件}z \notin \{x\} \cup FV(M) \cup FV(N)\text{的变量} \\<br>\end{cases}
\end{array}
$$</p><p>也可以展开来写</p><p>$$
\begin{array}{rcll}
x[x:=N] & \equiv & N & \\<br>y[x:=N] & \equiv & y &\text{其中}\ x\neq y \\<br>(M_1\ M_2)[x:=N] & \equiv & (M_1[x:=N])(M_2[x:=N]) & \\<br>(\lambda x.M)[x:=N] & \equiv & (\lambda x.M) & \\<br>(\lambda y.M)[x:=N] &\equiv& \lambda y.(M[x:=N]) & \text{其中} x\neq y,\text{且} x \notin FV(M) \lor y\notin FV(N) \\<br>(\lambda y.M)[x:=N] &\equiv& \lambda z.(M[y:=z][x:=N]) & \text{其中} x\neq y,\text{且} x \in FV(M) \land y\in FV(N)\text{，} \\<br>& & & z\text{为满足} y_n\notin FV(M) \land y_n\notin FV(N) \text{的，最小的}n\text{对应的}y_n
\end{array}
$$</p><h2 id=运算>运算</h2><h3 id=alpha变换>$\alpha$变换</h3><p>$\alpha$变换是约束变量的重命名。例如，下面的两个函数是等价的。形式参数$x$换成$y$是不影响函数的。</p><div class=tabs><ul class="nav nav-tabs"></ul><div class=tab-content><div class=tab-pane title=JavaScript><pre><code class=language-javascript>function(x) { return x + 1; }
function(y) { return y + 1; }
</code></pre></div><div class=tab-pane title=Racket><pre><code class=language-racket>(lambda (x) (+ x 1))
(lambda (y) (+ y 1))
</code></pre></div></div></div><p>$\alpha$等价($\lambda$-equivalent)表示在$\alpha$变换下保持等价的$\lambda$表达式。</p><p>$$\dfrac{}{x =_{\alpha} x} $$</p><p>$$\dfrac{M_1 =_{\alpha} M_2 \qquad N_1 =_{\alpha}N_2}{M_1\ M_2 =_{\alpha} N_1\ N_2}$$</p><p>$$\dfrac{M_1[x:=z] =_{\alpha} M_2[y:=z] \qquad z\notin FV(M_1)\cup FV(M_2) }{\lambda x.M_1=_{\alpha} \lambda y.M_2}$$</p><h3 id=beta归约>$\beta$归约</h3><p>$\beta$归约描述的是实参替换形参的过程，即函数应用的展开运算。</p><p>$$(\lambda x.M)\ N \to_{\beta} M[x := N]$$</p><p>具有左侧部分的形式的表达式可称为$\beta$<strong>可归约式</strong>（$\beta$ redex, $\beta$ reducible expression）。一个$\lambda$表达式中，可能出现多个$\beta$可归约式。按照下面的规则可以进行非确定的完全$\beta$归约。（非确定指同时多个可归约式时，归约的顺序不确定）</p><p>$$\dfrac{}{(\lambda x.M)\ N \to_{\beta} M[x := N]}\qquad\qquad \dfrac{M_1\to_{\beta}M_2}{M_1\ N\to_{\beta}M_2\ N}$$</p><p>$$\dfrac{M_1\to_{\beta}M_2}{\lambda x.M_1\to_{\beta}\lambda x.M_2}\qquad\qquad\qquad\qquad\dfrac{N_1\to_{\beta}N_2}{M\ N_1\to_{\beta}M\ N_2}$$</p><ul><li>一个$\beta$可归约式，显然地直接进行归约操作。（左上）</li><li>应用中的函数部分或实参部分出现$\beta$可归约式，则分别进行归约操作后再应用。（右）</li><li>抽象中的函数体出现$\beta$可归约式，可以先对函数体归约操作。（左下）</li></ul><p>不含$\beta$可归约式的$\lambda$项称为$\beta$<strong>范式</strong>(normal form)。通过以上规则，反复进行$\beta$归约后，可以得到$\beta$范式。但是，并不是所有的$\lambda$表达式都能归约到$\beta$范式。例如：
$$(\lambda x.x\ x)\ (\lambda x. x_ x) \to_{\beta} (\lambda x.x\ x)\ (\lambda x. x_ x)$$
这个式子会$\beta$归约到自身。它永远无法通过$\beta$归约去掉所有的$\beta$可归约式。</p><p>Church-Rosser定理表明，如果一个$\lambda$式存在$\beta$范式，则在$\alpha$等价的意义下，$\beta$范式是唯一的。不过值得注意的是，即便$\beta$范式存在，并不意味着按任意顺序归约都能得到$\beta$范式。例如：</p><p>$$
\begin{array}{rclcl}
(\lambda x.\lambda y.x)\ a\ ((\lambda x.x\ x)\ (\lambda x.x\ x)) &\to_{\beta} & ([a/x] (\lambda y.x))\ ((\lambda x.x\ x)\ (\lambda x.x\ x)) & \equiv & ((\lambda y.a))\ ((\lambda x.x\ x)\ (\lambda x.x\ x)) \\<br>&\to_{\beta} & ([((\lambda x.x\ x)\ (\lambda x.x\ x))/y]a)\ & \equiv & a
\end{array}
$$</p><p>以上经过两次$\beta$归约，可以得到$\beta$范式为$a$。如果执意先归约$((\lambda x.x\ x)\ (\lambda x.x\ x))$的部分，那便永远得不到$\beta$范式了。可见不恰当的归约顺序会导致陷入循环，无法得到$\beta$范式。</p><h3 id=eta变换>$\eta$变换</h3><p>$\eta$归约是$\lambda$演算中外延性的描述。</p><div class="card my-3 border-top-0 border-right-0 border-bottom-0 border-left border- rounded" style=border-width:4px!important><div class="wrap border border-left-0 rounded"><div class="card-header border-0 bg-white pl-3 text-"><h5>外延性（extensionality）</h5></div><div class="card-body pt-1"><p>两个对象相等，当且仅当它们的属性都相等。</p><ul><li>两个集合相等，当且仅当它们的元素相同。（外延公理）<ul><li>形式定义：$\forall P\forall Q[\forall X(X\in P\leftrightarrow X\in Q) \to P=Q]$</li></ul></li><li>两个函数相等，当且仅当对任意给定的参数，函数值对应相等。（注意，这里并没有比较函数内部的逻辑，而仅仅从外面的输入/输出来判断）<ul><li>$\forall f\forall g[\forall x(f(x)=g(x))\to f=g]$</li></ul></li><li>两个$\lambda$表达式相等，当且仅当应用到任意实参$x$时，两者相等。<ul><li>$\forall M\forall N[\forall x\notin\mathit{FV}(M)\cup\mathit{FV}(N)\ (\lambda x.M\ x = \lambda x.N\ x)\to M=N]$</li></ul></li></ul></div></div></div><p>$$\dfrac{x\notin \mathit{FV}(M)}{\lambda x.M\ x \to_{\eta} M}$$</p><p>($\eta$变换$\to$外延性) 若$f = g$，$x\notin\mathit{FV}(f)\cup\mathit{FV}(g)$，由$\eta$变换，$\lambda x.f\ x = \lambda x.g\ x$成立。</p><p>(外延性$\to\eta$变换) 若$(\lambda x. f\ x)\ y = f\ y$对任意的$y$成立。由外延性，$\lambda x.f\ x = f$成立。</p><h2 id=归约策略>归约策略</h2><p>当一个$\lambda$式中有多个可归约项时，归约运算的顺序便是归约策略（reduction strategies）。主要有以下两大类</p><ul><li>严格求值策略（strict evaluation strategy），也称及早求值（eager evaluation，又译热切求值），贪婪求值（greedy evaluation）。<ul><li>无论参数在函数体中是否被使用，总是先对参数进行求值运算。</li></ul></li><li>非严格求值策略（non-strict evaluation strategy），也称惰性求值（lazy evaluation，又译懒惰求值、惰性计算）。<ul><li>当且仅当参数在函数体中被使用时，对该参数进行求值运算。</li></ul></li></ul><blockquote><p>回顾可知，$\beta$规约是$(\lambda x.M) N \to_{\beta} M[x:=N] $。</p><p>再假设$N$也是可规约式。以上两类求值策略，主要就是$N$是否要先于整个式子的$\beta$规约进行规约计算。
先对$N$规约，则是严格求值策略；先对整个式子规约，则是非严格求值策略。</p></blockquote><p>以下是C语言描述的例子</p><pre><code class=language-c>int hello ( int parameter )
{
  printf (&quot; Hello World !&quot;) ;
  return 41;
}

int fac ( int n )
{
  if ( n == 0) return 1;
  else return n * fac ( n - 1) ;
}
</code></pre><ul><li><code>hello(fac(13))</code>: 如果以惰性求值，因为<code>fac(13)</code>在函数<code>hello</code>中并未被使用，因此是不会被计算的。<ul><li>惰性求值可以节省计算，提高效率。</li></ul></li><li><code>hello(hello(0))</code>: 如果以惰性求值，只会输出一个"Hello World!"，因为<code>hello(0)</code>在函数<code>hello</code>中并未被使用，因此不会被计算。<ul><li>惰性求值对副作用（side effect）是不友好的。<ul><li>函数<code>hello</code>的输入是整型的<code>parameter</code>，输出是整型常数<code>41</code>。而打印"Hello World!&ldquo;是该函数的一个副作用。</li><li>在常见的命令式编程语言中，副作用是常见的；而函数式编程语言往往要求函数没有副作用，即纯函数。</li></ul></li></ul></li></ul><h3 id=非严格求值>非严格求值</h3><h4 id=正常次序>正常次序</h4><p>正常次序(Normal order)是一种非严格求值策略。正常次序是指从最左边，最外层的可规约式进行求值计算。例如</p><p>$$
\begin{array}{rl}
& \underline{(\lambda x.x)((\lambda x.x)(\lambda z.(\lambda w.w) z))} \\<br>\to_{\beta} & \underline{(\lambda x.x)(\lambda z.(\lambda w.w) z)} \\<br>\to_{\beta} & \lambda z.\underline{(\lambda w.w) z} \\<br>\to_{\beta} & \lambda z.z \quad \nrightarrow<br>\end{array}
$$</p><p>如名字中“正常”两字所示，这是$\lambda$计算默认的求值策略。</p><h4 id=传名调用>传名调用</h4><p>传名调用（Call by name）求值策略和正常次序求值策略是很类似的。但是，传名调用只针对函数应用，将形参不做求值直接替换到函数体内。如果一个函数未被应用，那么函数体中的可规约式不会被求值。例如：</p><p>$$
\begin{array}{rl}
& \underline{(\lambda x.x)((\lambda x.x)(\lambda z.(\lambda w.w) z))} \\<br>\to_{\beta} & \underline{(\lambda x.x)(\lambda z.(\lambda w.w) z)} \\<br>\to_{\beta} & \lambda z.(\lambda w.w) z \quad \nrightarrow<br>\end{array}
$$</p><p>最后一行是一个函数，其形参为$z$，函数体为$(\lambda w.w) z$。函数未被应用，没有实参。传名调用求值策略的计算就到此为止了。函数体部分虽然有可规约式，却不会被计算求值了。这就是传名调用策略和正常次序策略的不同。</p><h4 id=传需求调用>传需求调用</h4><p>传需求调用(Call by need)是传名调用的记忆化（memorized）版本。对于纯函数，同样的输入参数一定会得到同样的输入结果。因此，记忆化缓存计算结果，可以节省重复计算的开销，提高性能。对于有副作用的部分，Haskell语言采用Monad（单子），消除了值的改变优先于延迟运算的不确定性问题。</p><blockquote><ul><li>键盘读取值$x$，然后计算$\sqrt{x}$。<ul><li>这个是不纯的，因为$x$无法预测。</li></ul></li><li>如果键盘读取值$x$，那么计算$\sqrt{x}$。</li></ul></blockquote><h4 id=传宏展开调用>传宏展开调用</h4><p>传宏展开调用（Call by macro expansion）和传名调用是类似的。</p><h3 id=严格求值>严格求值</h3><h4 id=应用序>应用序</h4><h4 id=按值调用>按值调用</h4><h2 id=实例>实例</h2><h3 id=邱奇编码>邱奇编码</h3><p>邱奇编码是把数据和运算符嵌入到lambda演算内的一种方式，方法得名于阿隆佐·邱奇。透过邱奇编码，在其他符号系统中通常被认定为基本的项（比如整数、布尔值、有序对、列表和tagged unions）都会被映射到高阶函数。在无型别lambda演算，函数是唯一的原始型别。</p><h4 id=邱奇数>邱奇数</h4><p>在数学中，函数$f: X\to Y$和$g: Y\to Z$可以复合得到函数$g\circ f: X\to Z$，定义为$(g\circ f)(x)=g(f(x))$。$n$重复合函数可以写成如下形式：</p><p>$$f^{\circ n}=\underbrace{f\circ f\circ f \circ \cdots \circ f}_{n\text{个}}$$</p><h3 id=递归>递归</h3><div class=row></div></div></div></div><script src=https://book.cherrysky.org/programming/lib/jquery.min.js></script><script src=https://book.cherrysky.org/programming/lib/popper.min.js></script><script src=https://book.cherrysky.org/programming/js/bootstrap.min.js></script><script src=https://book.cherrysky.org/programming/js/tabs.js></script><script src=https://book.cherrysky.org/programming/js/table.js></script><script src=https://book.cherrysky.org/programming/js/tree.js></script><script type=text/javascript src=/programming/plugins/lunr.min.js></script><script type=text/javascript src=/programming/plugins/auto-complete.js></script><link href=/programming/plugins/auto-complete.css rel=stylesheet><script type=text/javascript>var baseurl="https:\/\/book.cherrysky.org\/programming\/";</script><script type=text/javascript src=/programming/plugins/search.js></script><script type=text/javascript src=/programming/plugins/clipboard.js></script><script>new ClipboardJS('.btn');</script></body></html>